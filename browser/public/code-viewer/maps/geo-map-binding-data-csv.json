{
 "sampleFiles":
[
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-data-csv/src/index.tsx",
  "content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport WorldUtils from \"./WorldUtils\"\nimport { IgrGeographicMapModule } from 'igniteui-react-maps';\nimport { IgrGeographicMap } from 'igniteui-react-maps';\nimport { IgrGeographicHighDensityScatterSeries } from 'igniteui-react-maps';\nimport { IgrDataChartInteractivityModule } from 'igniteui-react-charts';\nimport { IgrDataContext } from 'igniteui-react-core';\n\nIgrGeographicMapModule.register();\nIgrDataChartInteractivityModule.register();\n\nexport default class MapBindingDataCSV extends React.Component {\n\n    public geoMap: IgrGeographicMap;\n\n    constructor(props: any) {\n        super(props);\n\n        this.onMapRef = this.onMapRef.bind(this);\n    }\n\n    public render(): JSX.Element {\n        return (\n            <div className=\"container sample\">\n                <div className=\"container\" >\n                    <IgrGeographicMap\n                        ref={this.onMapRef}\n                        width=\"100%\"\n                        height=\"100%\"\n                        zoomable=\"true\"/>\n                </div>\n                <div className=\"overlay-bottom-right overlay-border\">Imagery Tiles: @OpenStreetMap</div>\n            </div>\n        );\n    }\n\n    public onMapRef(geoMap: IgrGeographicMap) {\n        if (!geoMap) { return; }\n\n        this.geoMap = geoMap;\n    }\n\n    public componentDidMount() {\n        // fetching JSON data with geographic locations from public folder\n\n        fetch(\"https://static.infragistics.com/xplatform/data/UsaCitiesPopulation.csv\")\n            .then((response) => response.text())\n            .then(data => this.onDataLoaded(data));\n    }\n\n    public onDataLoaded(csvData: string) {\n        const csvLines = csvData.split(\"\\n\");\n        // console.log(\"loaded UsaCitiesPopulation.csv \" + csvLines.length);\n\n        // parsing CSV data and creating geographic locations\n        const geoLocations: any[] = [];\n        for (let i = 1; i < csvLines.length; i++) {\n            const columns = csvLines[i].split(\",\");\n            const location = {\n                latitude:  Number(columns[1]),\n                longitude: Number(columns[2]),\n                name:  columns[0],\n                population: Number(columns[3])\n            };\n            geoLocations.push(location);\n        }\n\n        // creating HD series with loaded data\n        const geoSeries = new IgrGeographicHighDensityScatterSeries( { name: \"hdSeries\" });\n        geoSeries.dataSource = geoLocations;\n        geoSeries.latitudeMemberPath  = \"latitude\";\n        geoSeries.longitudeMemberPath = \"longitude\";\n        geoSeries.heatMaximumColor = \"Red\";\n        geoSeries.heatMinimumColor = \"Black\";\n        geoSeries.heatMinimum = 0;\n        geoSeries.heatMaximum = 5;\n        geoSeries.pointExtent = 1;\n        geoSeries.tooltipTemplate = this.createTooltip;\n        geoSeries.mouseOverEnabled = true;\n\n        // adding symbol series to the geographic amp\n        this.geoMap.series.add(geoSeries);\n\n        // zooming to bound of lower 48-states\n        const geoBounds = {\n            left: -130,\n            top: 15,\n            width: Math.abs(-130 + 65),\n            height: Math.abs(50 - 15)\n        };\n        this.geoMap.zoomToGeographic(geoBounds);\n    }\n\n    public createTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const series = dataContext.series as any;\n        if (!series) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        const lat = WorldUtils.toStringLat(dataItem.latitude);\n        const lon = WorldUtils.toStringLon(dataItem.longitude);\n        const population = WorldUtils.toStringAbbr(dataItem.population);\n\n        return <div>\n            <div className=\"tooltipTitle\">{dataItem.name}</div>\n            <div className=\"tooltipBox\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Latitude:</div>\n                    <div className=\"tooltipVal\">{lat}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Longitude:</div>\n                    <div className=\"tooltipVal\">{lon}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Population: </div>\n                    <div className=\"tooltipVal\">{population}</div>\n                </div>\n            </div>\n        </div>\n    }\n\n}\n\n// rendering above class to the React DOM\nReactDOM.render(<MapBindingDataCSV />, document.getElementById('root'));\n",
  "isMain": true,
  "fileExtension": "tsx",
  "fileHeader": "tsx"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-data-csv/src/index.css",
  "content": "",
  "isMain": true,
  "fileExtension": "css",
  "fileHeader": "css"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-data-csv/src/WorldUtils.ts",
  "content": "export default class WorldUtils {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        let interval = 200;\r\n        let paths: any[] = [[]];\r\n        let pathID = 0;\r\n        let distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval)\r\n            {\r\n                previous = current\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                let bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: -180, lat: current.lat }\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: 180, lat: current.lat }\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number\r\n    {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let range = (dest.lon - origin.lon);\r\n        let y = Math.sin(range) * Math.cos(dest.lat);\r\n        let x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        let angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        let radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180º and +180º\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon: lon, lat: lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        let lonDelta = (dest.lon - origin.lon);\r\n\r\n        let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        let distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        let x = this.toRadians(geoPoint.lon);\r\n        let y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number\r\n    {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number\r\n    {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        let str = Math.abs(latitude).toFixed(1) + \"°\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        let val = Math.abs(coordinate);\r\n        let str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\"\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\"\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\"\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\"\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) return location.x;\r\n        if (location.lon) return location.lon;\r\n        if (location.longitude) return location.longitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) return location.y;\r\n        if (location.lat) return location.lat;\r\n        if (location.latitude) return location.latitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n\r\n            // if (location.x) {\r\n            //     minLon = Math.min(minLon, location.x);\r\n            //     maxLon = Math.max(maxLon, location.x);\r\n            // } else if (location.lon) {\r\n            //     minLon = Math.min(minLon, location.lon);\r\n            //     maxLon = Math.max(maxLon, location.lon);\r\n            // } else if (location.longitude) {\r\n            //     minLon = Math.min(minLon, location.longitude);\r\n            //     maxLon = Math.max(maxLon, location.longitude);\r\n            // }\r\n            // if (location.y) {\r\n            //     minLat = Math.min(minLat, location.y);\r\n            //     maxLat = Math.max(maxLat, location.y);\r\n            // } else if (location.lat) {\r\n            //     minLat = Math.min(minLat, location.lat);\r\n            //     maxLat = Math.max(maxLat, location.lat);\r\n            // } else if (location.latitude) {\r\n            //     minLat = Math.min(minLat, location.latitude);\r\n            //     maxLat = Math.max(maxLat, location.latitude);\r\n            // }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n\r\n    public static getNightShapes(): any[] {\r\n        let nightShape = [];\r\n\r\n        let line: any[] = [];\r\n\r\n        for (let lon = -180; lon <= 180; lon += 1) {\r\n\r\n            // let line: any[] = [{x: lon, y: -90}, {x: lon, y: 90}];\r\n            let x = lon;\r\n            let y = 75 * Math.cos(lon * Math.PI / 180);\r\n            line.push({x: x, y: y});\r\n        }\r\n        // line.push({x: 180, y: 90});\r\n        // line.push({x: -180, y: 90});\r\n        // line.push({x: -180, y: -90});\r\n\r\n        let coordinateLine = {points: [line]};\r\n\r\n        nightShape.push(coordinateLine);\r\n\r\n        return nightShape;\r\n    }\r\n\r\n}",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 }
]
}