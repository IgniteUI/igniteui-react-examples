{
 "sampleFiles":
[
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-data-model/src/index.tsx",
  "content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport WorldUtils from \"./WorldUtils\"\nimport { IgrGeographicMapModule } from 'igniteui-react-maps';\nimport { IgrGeographicMap } from 'igniteui-react-maps';\nimport { IgrGeographicSymbolSeries } from 'igniteui-react-maps';\nimport { IgrGeographicPolylineSeries } from 'igniteui-react-maps';\nimport { IgrDataChartInteractivityModule } from 'igniteui-react-charts';\nimport { MarkerType } from 'igniteui-react-charts';\nimport { IgrDataContext } from 'igniteui-react-core';\n\nIgrGeographicMapModule.register();\nIgrDataChartInteractivityModule.register();\n\nexport default class MapBindingDataModel extends React.Component {\n\n    public geoMap: IgrGeographicMap;\n    public flights: any[];\n\n    constructor(props: any) {\n        super(props);\n\n        const cityDAL = { lat:  32.763, lon: -96.663, country: \"US\", name: \"Dallas\" };\n        const citySYD = { lat: -33.889, lon: 151.028, country: \"Australia\", name: \"Sydney\" };\n        const cityNZL = { lat: -36.848, lon: 174.763, country: \"New Zealand\", name: \"Auckland\" };\n        const cityQTR = { lat: 25.285, lon:  51.531,  country: \"Qatar\", name: \"Doha\" };\n        const cityPAN = { lat:  8.949, lon: -79.400,  country: \"Panama\", name: \"Panama\" };\n        const cityCHL = { lat: -33.475, lon: -70.647, country: \"Chile\", name: \"Santiago\" };\n        const cityJAP = { lat:  35.683, lon: 139.809, country: \"Japan\", name: \"Tokyo\" };\n        const cityALT = { lat: 33.795,  lon: -84.349, country: \"US\", name: \"Atlanta\" };\n        const cityJOH = { lat: -26.178, lon: 28.004,  country: \"South Africa\", name: \"Johannesburg\" };\n        const cityNYC = { lat: 40.750, lon: -74.0999, country: \"US\", name: \"New York\" };\n        const citySNG = { lat:  1.229, lon: 104.177,  country: \"Singapore\", name: \"Singapore\" };\n        const cityMOS = { lat: 55.750, lon:  37.700,  country: \"Russia\", name: \"Moscow\" };\n        const cityROM = { lat:  41.880, lon: 12.520,  country: \"Italy\", name: \"Roma\" };\n        const cityLAX = { lat: 34.000, lon: -118.25,  country: \"US\", name: \"Los Angeles\" };\n\n        this.flights = [\n            { origin: cityDAL, dest: citySNG, color: \"Green\" },\n            { origin: cityMOS, dest: cityNZL, color: \"Red\" },\n            { origin: cityCHL, dest: cityJAP, color: \"Blue\" },\n            { origin: cityPAN, dest: cityROM, color: \"Orange\" },\n            { origin: cityALT, dest: cityJOH, color: \"Black\" },\n            { origin: cityNYC, dest: cityQTR, color: \"Purple\" },\n            { origin: cityLAX, dest: citySYD, color: \"Gray\" },\n        ];\n\n        this.onMapRef = this.onMapRef.bind(this);\n        this.createSymbolTooltip = this.createSymbolTooltip.bind(this);\n    }\n\n    public render(): JSX.Element {\n        return (\n            <div className=\"container sample\">\n                <div className=\"container\" >\n                    <IgrGeographicMap\n                        ref={this.onMapRef}\n                        width=\"100%\"\n                        height=\"100%\"\n                        zoomable=\"true\"/>\n                </div>\n                <div className=\"overlay-bottom-right overlay-border\">Imagery Tiles: @OpenStreetMap</div>\n            </div>\n        );\n    }\n\n    public onMapRef(geoMap: IgrGeographicMap) {\n        if (!geoMap) { return; }\n\n        this.geoMap = geoMap;\n        this.geoMap.windowRect = { left: 0.2, top: 0.1, width: 0.6, height: 0.6 };\n\n        // const geoRegion = { height: 170, left: -180, top: -85.0, width: 360 };\n        // this.geoMap.zoomToGeographic(geoRegion);\n\n        for (const flight of this.flights) {\n            this.createPolylineSeries(flight);\n            this.createSymbolSeries(flight);\n        }\n    }\n\n    public createSymbolSeries(flight: any)\n    {\n        const geoLocations = [flight.origin, flight.dest ];\n\n        const symbolSeries = new IgrGeographicSymbolSeries ( { name: \"symbolSeries\" });\n        symbolSeries.dataSource = geoLocations;\n        symbolSeries.markerType = MarkerType.Circle;\n        symbolSeries.latitudeMemberPath = \"lat\";\n        symbolSeries.longitudeMemberPath = \"lon\";\n        symbolSeries.markerBrush  = \"White\";\n        symbolSeries.markerOutline = flight.color;\n        symbolSeries.thickness = 1;\n        symbolSeries.tooltipTemplate = this.createSymbolTooltip;\n\n        this.geoMap.series.add(symbolSeries);\n    }\n\n    public createPolylineSeries(flight: any)\n    {\n        const geoPath = WorldUtils.calcPaths(flight.origin, flight.dest);\n        const geoDistance = WorldUtils.calcDistance(flight.origin, flight.dest);\n        const geoRoutes = [\n            { points: geoPath ,\n              origin: flight.origin,\n              dest: flight.dest,\n              distance: geoDistance,\n              time: geoDistance / 850,\n        }];\n\n        const lineSeries = new IgrGeographicPolylineSeries ( { name: \"lineSeries\" });\n        lineSeries.dataSource = geoRoutes;\n        lineSeries.shapeMemberPath = \"points\";\n        lineSeries.shapeStrokeThickness = 9;\n        lineSeries.shapeOpacity = 0.5;\n        lineSeries.shapeStroke = flight.color;\n        lineSeries.tooltipTemplate = this.createPolylineTooltip;\n        this.geoMap.series.add(lineSeries);\n    }\n\n    public createSymbolTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        // console.log(\"createSymbolTooltip\");\n        const lat = WorldUtils.toStringLat(dataItem.lat);\n        const lon = WorldUtils.toStringLon(dataItem.lon);\n        const brush = dataContext.series.markerOutline;\n        const style = { color: brush } as React.CSSProperties;\n\n        return <div >\n            <div className=\"tooltipTitle\" style={style}> {dataItem.name}</div>\n            <div className=\"tooltipBox\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Country:</div>\n                    <div className=\"tooltipVal\">{dataItem.country}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Latitude:</div>\n                    <div className=\"tooltipVal\">{lat}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Longitude:</div>\n                    <div className=\"tooltipVal\">{lon}</div>\n                </div>\n            </div>\n        </div>\n    }\n\n    public createPolylineTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        // const brush = dataContext.series.shapeStroke\n        // const style = { color: brush } as React.CSSProperties;\n\n        return <div>\n            <div className=\"tooltipTitle\" >{dataItem.origin.name} - {dataItem.dest.name}</div>\n            <div className=\"tooltipBox\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Distance:</div>\n                    <div className=\"tooltipVal\">{dataItem.distance.toFixed(0)} km</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Duration:</div>\n                    <div className=\"tooltipVal\">{dataItem.time.toFixed(1)} h</div>\n                </div>\n            </div>\n        </div>\n    }\n}\n\n// rendering above class to the React DOM\nReactDOM.render(<MapBindingDataModel />, document.getElementById('root'));\n",
  "isMain": true,
  "fileExtension": "tsx",
  "fileHeader": "tsx"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-data-model/src/index.css",
  "content": "",
  "isMain": true,
  "fileExtension": "css",
  "fileHeader": "css"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-data-model/src/WorldUtils.ts",
  "content": "export default class WorldUtils {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        let interval = 200;\r\n        let paths: any[] = [[]];\r\n        let pathID = 0;\r\n        let distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval)\r\n            {\r\n                previous = current\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                let bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: -180, lat: current.lat }\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: 180, lat: current.lat }\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number\r\n    {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let range = (dest.lon - origin.lon);\r\n        let y = Math.sin(range) * Math.cos(dest.lat);\r\n        let x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        let angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        let radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180º and +180º\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon: lon, lat: lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        let lonDelta = (dest.lon - origin.lon);\r\n\r\n        let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        let distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        let x = this.toRadians(geoPoint.lon);\r\n        let y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number\r\n    {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number\r\n    {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        let str = Math.abs(latitude).toFixed(1) + \"°\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        let val = Math.abs(coordinate);\r\n        let str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\"\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\"\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\"\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\"\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) return location.x;\r\n        if (location.lon) return location.lon;\r\n        if (location.longitude) return location.longitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) return location.y;\r\n        if (location.lat) return location.lat;\r\n        if (location.latitude) return location.latitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n\r\n            // if (location.x) {\r\n            //     minLon = Math.min(minLon, location.x);\r\n            //     maxLon = Math.max(maxLon, location.x);\r\n            // } else if (location.lon) {\r\n            //     minLon = Math.min(minLon, location.lon);\r\n            //     maxLon = Math.max(maxLon, location.lon);\r\n            // } else if (location.longitude) {\r\n            //     minLon = Math.min(minLon, location.longitude);\r\n            //     maxLon = Math.max(maxLon, location.longitude);\r\n            // }\r\n            // if (location.y) {\r\n            //     minLat = Math.min(minLat, location.y);\r\n            //     maxLat = Math.max(maxLat, location.y);\r\n            // } else if (location.lat) {\r\n            //     minLat = Math.min(minLat, location.lat);\r\n            //     maxLat = Math.max(maxLat, location.lat);\r\n            // } else if (location.latitude) {\r\n            //     minLat = Math.min(minLat, location.latitude);\r\n            //     maxLat = Math.max(maxLat, location.latitude);\r\n            // }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n\r\n    public static getNightShapes(): any[] {\r\n        let nightShape = [];\r\n\r\n        let line: any[] = [];\r\n\r\n        for (let lon = -180; lon <= 180; lon += 1) {\r\n\r\n            // let line: any[] = [{x: lon, y: -90}, {x: lon, y: 90}];\r\n            let x = lon;\r\n            let y = 75 * Math.cos(lon * Math.PI / 180);\r\n            line.push({x: x, y: y});\r\n        }\r\n        // line.push({x: 180, y: 90});\r\n        // line.push({x: -180, y: 90});\r\n        // line.push({x: -180, y: -90});\r\n\r\n        let coordinateLine = {points: [line]};\r\n\r\n        nightShape.push(coordinateLine);\r\n\r\n        return nightShape;\r\n    }\r\n\r\n}",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 }
]
}