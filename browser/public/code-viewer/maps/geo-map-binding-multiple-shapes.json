{
 "sampleFiles":
[
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-multiple-shapes/src/index.tsx",
  "content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport WorldUtils from \"./WorldUtils\"\nimport { IgrGeographicMapImagery } from 'igniteui-react-maps';\nimport { IgrGeographicMapModule } from 'igniteui-react-maps';\nimport { IgrGeographicMap } from 'igniteui-react-maps';\nimport { IgrGeographicShapeSeries } from 'igniteui-react-maps';\nimport { IgrGeographicPolylineSeries } from 'igniteui-react-maps';\nimport { IgrGeographicSymbolSeries } from 'igniteui-react-maps';\nimport { IgrDataChartInteractivityModule } from 'igniteui-react-charts';\nimport { IgrDataContext } from 'igniteui-react-core';\nimport { IgrShapeDataSource } from 'igniteui-react-core';\n\nIgrGeographicMapModule.register();\nIgrDataChartInteractivityModule.register();\n\nexport default class MapBindingMultipleShapes extends React.Component<any, any> {\n\n    public geoMap: IgrGeographicMap;\n\n    constructor(props: any) {\n        super(props);\n\n        this.onMapRef = this.onMapRef.bind(this);\n        this.onPointsLoaded = this.onPointsLoaded.bind(this);\n        this.onPolylinesLoaded = this.onPolylinesLoaded.bind(this);\n        this.onPolygonsLoaded = this.onPolygonsLoaded.bind(this);\n\n        this.state = { locations: [], polylines: [], polygons: []}\n    }\n\n    public render(): JSX.Element {\n        const mapStyle = { background: \"rgb(212, 212, 212)\" } as React.CSSProperties;\n\n        return (\n            <div className=\"container sample\">\n                <div className=\"container\" style={mapStyle} >\n                    <IgrGeographicMap\n                        ref={this.onMapRef}\n                        width=\"100%\"\n                        height=\"100%\"\n                        zoomable=\"true\" >\n                        <IgrGeographicShapeSeries\n                            name=\"polygonSeries\"\n                        //    tooltipTemplate={this.getPolygonTooltip}\n                            dataSource={this.state.polygons}\n                            shapeMemberPath=\"points\"\n                            shapeFill=\"rgb(150, 150, 150)\"\n                            shapeStroke=\"Black\"\n                            shapeStrokeThickness={1.0} />\n                        <IgrGeographicPolylineSeries\n                              name=\"lineSeries\"\n                           //    tooltipTemplate={this.getPolygonTooltip}\n                             dataSource={this.state.polylines}\n                             shapeMemberPath=\"points\"\n                             shapeStroke=\"rgba(147, 15, 180, 0.5)\"\n                             thickness={3.0}  />\n                        <IgrGeographicSymbolSeries\n                            name=\"symbolSeries\"\n                        //    tooltipTemplate={this.getSymbolTooltip}\n                            dataSource={this.state.locations}\n                            longitudeMemberPath=\"longitude\"\n                            latitudeMemberPath=\"latitude\"\n                            markerType=\"Circle\"\n                            markerOutline=\"rgb(2, 102, 196)\"\n                            markerBrush=\"White\" />\n                   </IgrGeographicMap>\n                </div>\n            </div>\n        );\n    }\n\n    public onMapRef(geoMap: IgrGeographicMap) {\n        if (!geoMap) { return; }\n\n        this.geoMap = geoMap;\n        this.geoMap.backgroundContent = undefined;\n        this.geoMap.windowRect = { left: 0.2, top: 0.1, width: 0.6, height: 0.6 };\n\n        // console.log(\"series.count \" + this.geoMap.series.count);\n        // console.log(\"actualSeries.length \" + this.geoMap.actualSeries.length);\n\n        this.geoMap.actualSeries[0].tooltipTemplate = this.getPolygonsTooltip;\n        this.geoMap.actualSeries[1].tooltipTemplate = this.getPolylinesTooltip;\n        this.geoMap.actualSeries[2].tooltipTemplate = this.getPointTooltip;\n\n        // loading a shapefile with geographic polygons\n        const sdsPolygons = new IgrShapeDataSource();\n        sdsPolygons.importCompleted = this.onPolygonsLoaded;\n        sdsPolygons.shapefileSource = \"https://static.infragistics.com/xplatform/shapes/WorldCountries.shp\";\n        sdsPolygons.databaseSource  = \"https://static.infragistics.com/xplatform/shapes/WorldCountries.dbf\";\n        sdsPolygons.dataBind();\n\n        const sdsPolylines = new IgrShapeDataSource();\n        sdsPolylines.importCompleted = this.onPolylinesLoaded;\n        sdsPolylines.shapefileSource = \"https://static.infragistics.com/xplatform/shapes/WorldCableRoutes.shp\";\n        sdsPolylines.databaseSource  = \"https://static.infragistics.com/xplatform/shapes/WorldCableRoutes.dbf\";\n        sdsPolylines.dataBind();\n\n        // loading a shapefile with geographic points\n        const sdsPoints = new IgrShapeDataSource();\n        sdsPoints.importCompleted = this.onPointsLoaded;\n        sdsPoints.shapefileSource = \"https://static.infragistics.com/xplatform/shapes/WorldCities.shp\";\n        sdsPoints.databaseSource  = \"https://static.infragistics.com/xplatform/shapes/WorldCities.dbf\";\n        sdsPoints.dataBind();\n    }\n\n    public onPointsLoaded(sds: IgrShapeDataSource, e: any) {\n        console.log(\"onPointsLoaded\");\n\n        const geoLocations: any[] = [];\n        // parsing shapefile data and creating geo-locations\n        for (const record of sds.getPointData()) {\n            const pop = record.fieldValues.POPULATION;\n            // each shapefile record has just one point\n            const location = {\n                latitude: record.points[0][0].y,\n                longitude: record.points[0][0].x,\n                city: record.fieldValues.NAME,\n                population: pop\n            };\n            geoLocations.push(location);\n        }\n        this.setState({ locations: geoLocations });\n    }\n\n    public onPolylinesLoaded(sds: IgrShapeDataSource, e: any) {\n        console.log(\"onPolylinesLoaded\");\n\n        const geoPolylines: any[] = [];\n        // parsing shapefile data and creating geo-polygons\n        sds.getPointData().forEach(record => {\n            // using field/column names from .DBF file\n            const route = {\n                points: record.points,\n                name: record.fieldValues.Name,\n                capacity: record.fieldValues.CapacityG,\n                distance: record.fieldValues.DistanceKM\n            };\n            geoPolylines.push(route);\n        });\n\n        this.setState({ polylines: geoPolylines });\n    }\n\n    public onPolygonsLoaded(sds: IgrShapeDataSource, e: any) {\n        console.log(\"onPolygonsLoaded \");\n\n        const geoPolygons: any[] = [];\n        // parsing shapefile data and creating geo-polygons\n        sds.getPointData().forEach(record => {\n            // using field/column names from .DBF file\n            const country = {\n                points: record.points,\n                name: record.fieldValues.NAME,\n                gdp: record.fieldValues.GDP,\n                population: record.fieldValues.POPULATION\n            };\n            geoPolygons.push(country);\n        });\n\n        this.setState({ polygons: geoPolygons });\n    }\n\n    public getPolygonsTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const series = dataContext.series as any;\n        if (!series) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        const pop = WorldUtils.toStringAbbr(dataItem.population);\n        const gdp = WorldUtils.toStringAbbr(dataItem.gdp * 1000000 / dataItem.population);\n        const brush = series.shapeStroke;\n\n        return <div className=\"tooltipBox\">\n            <div className=\"tooltipTitle\" style={{ color: brush }}>{dataItem.name}</div>\n            <div className=\"tooltipTable\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Population</div>\n                    <div className=\"tooltipVal\">{pop}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">GDP</div>\n                    <div className=\"tooltipVal\">{gdp}</div>\n                </div>\n            </div>\n        </div>\n    }\n\n    public getPointTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const series = dataContext.series as any;\n        if (!series) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        const brush = series.markerOutline;\n        const pop = WorldUtils.toStringAbbr(dataItem.population);\n        const lat = WorldUtils.toStringLat(dataItem.latitude);\n        const lon = WorldUtils.toStringLon(dataItem.longitude);\n\n        return <div className=\"tooltipBox\">\n            <div className=\"tooltipTitle\" style={{ color: brush }}>{dataItem.city}</div>\n            <div className=\"tooltipTable\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Latitude:</div>\n                    <div className=\"tooltipVal\">{lat}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Longitude:</div>\n                    <div className=\"tooltipVal\">{lon}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Population:</div>\n                    <div className=\"tooltipVal\">{pop}</div>\n                </div>\n            </div>\n        </div>\n    }\n\n    public getPolylinesTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const series = dataContext.series as any;\n        if (!series) return null;\n\n        // console.log(\"getPolylinesTooltip.series \" );\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        const capacity = dataItem.capacity + \" GB/s\";\n        const distance = dataItem.distance + \" KM\";\n\n        return <div className=\"tooltipBox\">\n            <div className=\"tooltipTitle\" style={{ color: \"Purple\" }}>{dataItem.name}</div>\n            <div className=\"tooltipTable\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Distance</div>\n                    <div className=\"tooltipVal\">{distance}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Capacity</div>\n                    <div className=\"tooltipVal\">{capacity}</div>\n                </div>\n            </div>\n        </div>\n    }\n\n}\n\n// rendering above class to the React DOM\nReactDOM.render(<MapBindingMultipleShapes />, document.getElementById('root'));\n",
  "isMain": true,
  "fileExtension": "tsx",
  "fileHeader": "tsx"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-multiple-shapes/src/index.css",
  "content": "",
  "isMain": true,
  "fileExtension": "css",
  "fileHeader": "css"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/binding-multiple-shapes/src/WorldUtils.ts",
  "content": "export default class WorldUtils {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        let interval = 200;\r\n        let paths: any[] = [[]];\r\n        let pathID = 0;\r\n        let distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval)\r\n            {\r\n                previous = current\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                let bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: -180, lat: current.lat }\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: 180, lat: current.lat }\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number\r\n    {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let range = (dest.lon - origin.lon);\r\n        let y = Math.sin(range) * Math.cos(dest.lat);\r\n        let x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        let angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        let radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180º and +180º\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon: lon, lat: lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        let lonDelta = (dest.lon - origin.lon);\r\n\r\n        let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        let distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        let x = this.toRadians(geoPoint.lon);\r\n        let y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number\r\n    {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number\r\n    {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        let str = Math.abs(latitude).toFixed(1) + \"°\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        let val = Math.abs(coordinate);\r\n        let str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\"\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\"\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\"\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\"\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) return location.x;\r\n        if (location.lon) return location.lon;\r\n        if (location.longitude) return location.longitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) return location.y;\r\n        if (location.lat) return location.lat;\r\n        if (location.latitude) return location.latitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n\r\n            // if (location.x) {\r\n            //     minLon = Math.min(minLon, location.x);\r\n            //     maxLon = Math.max(maxLon, location.x);\r\n            // } else if (location.lon) {\r\n            //     minLon = Math.min(minLon, location.lon);\r\n            //     maxLon = Math.max(maxLon, location.lon);\r\n            // } else if (location.longitude) {\r\n            //     minLon = Math.min(minLon, location.longitude);\r\n            //     maxLon = Math.max(maxLon, location.longitude);\r\n            // }\r\n            // if (location.y) {\r\n            //     minLat = Math.min(minLat, location.y);\r\n            //     maxLat = Math.max(maxLat, location.y);\r\n            // } else if (location.lat) {\r\n            //     minLat = Math.min(minLat, location.lat);\r\n            //     maxLat = Math.max(maxLat, location.lat);\r\n            // } else if (location.latitude) {\r\n            //     minLat = Math.min(minLat, location.latitude);\r\n            //     maxLat = Math.max(maxLat, location.latitude);\r\n            // }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n\r\n    public static getNightShapes(): any[] {\r\n        let nightShape = [];\r\n\r\n        let line: any[] = [];\r\n\r\n        for (let lon = -180; lon <= 180; lon += 1) {\r\n\r\n            // let line: any[] = [{x: lon, y: -90}, {x: lon, y: 90}];\r\n            let x = lon;\r\n            let y = 75 * Math.cos(lon * Math.PI / 180);\r\n            line.push({x: x, y: y});\r\n        }\r\n        // line.push({x: 180, y: 90});\r\n        // line.push({x: -180, y: 90});\r\n        // line.push({x: -180, y: -90});\r\n\r\n        let coordinateLine = {points: [line]};\r\n\r\n        nightShape.push(coordinateLine);\r\n\r\n        return nightShape;\r\n    }\r\n\r\n}",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 }
]
}