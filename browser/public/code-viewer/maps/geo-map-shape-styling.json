{
 "sampleFiles":
[
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/shape-styling/src/index.tsx",
  "content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport WorldUtils from \"./WorldUtils\"\nimport { ShapeStyling } from './MapShapeStyleUtility';\nimport { ShapeScaleStyling } from './MapShapeStyleUtility';\nimport { ShapeRangeStyling } from './MapShapeStyleUtility';\nimport { ShapeRandomStyling } from './MapShapeStyleUtility';\nimport { ShapeComparisonStyling } from './MapShapeStyleUtility';\nimport { IgrGeographicMap } from 'igniteui-react-maps';\nimport { IgrGeographicMapModule } from 'igniteui-react-maps';\nimport { IgrGeographicShapeSeries } from 'igniteui-react-maps';\nimport { IgrDataChartInteractivityModule } from 'igniteui-react-charts';\nimport { IgrShapeDataSource } from 'igniteui-react-core';\nimport { IgrShapefileRecord } from 'igniteui-react-core';\nimport { IgrStyleShapeEventArgs } from 'igniteui-react-charts';\nimport { IgrDataContext } from 'igniteui-react-core';\n\nIgrGeographicMapModule.register();\nIgrDataChartInteractivityModule.register();\n\nexport default class MapShapeStyling extends React.Component<any, any> {\n\n    public geoMap: IgrGeographicMap;\n    public geoSeries: IgrGeographicShapeSeries;\n    public shapeRecords: any[] = [];\n\n    public currentShapeStyling: ShapeStyling;\n    public shapeRandomStyling: ShapeRandomStyling;\n    public shapeComparisonStyling: ShapeComparisonStyling;\n    public shapeScaleStyling: ShapeScaleStyling;\n    public shapeRangeStyling: ShapeRangeStyling;\n\n    constructor(props: any) {\n        super(props);\n\n        this.state = { stylingType: \"ShapeComparisonStyling\"}\n\n        this.onMapRef = this.onMapRef.bind(this);\n        this.onDataLoaded = this.onDataLoaded.bind(this);\n        this.onOptionsSelected = this.onOptionsSelected.bind(this);\n        this.onStylingShape = this.onStylingShape.bind(this);\n        this.createTooltip = this.createTooltip.bind(this);\n\n        // setting up ShapeRandomStyling:\n        this.shapeRandomStyling = new ShapeRandomStyling();\n        this.shapeRandomStyling.shapeStrokeColors = ['Black'];\n        this.shapeRandomStyling.shapeFillColors = ['#8C23D1', '#0E9759', '#B4D336', '#F2A464', '#D74545', 'DodgerBlue'];\n\n        // setting up ShapeScaleStyling:\n        this.shapeScaleStyling = new ShapeScaleStyling();\n        this.shapeScaleStyling.defaultFill = 'Gray';\n        this.shapeScaleStyling.shapeStrokeColors = ['Black'];\n        this.shapeScaleStyling.shapeFillColors = ['DodgerBlue', 'yellow', '#c2f542', '#e8c902', '#e8b602', '#e87902', 'brown'];\n        this.shapeScaleStyling.itemMinimumValue = 5000;\n        this.shapeScaleStyling.itemMaximumValue = 2000000000; // 2 Billions\n        this.shapeScaleStyling.itemMemberPath = 'Population';\n        this.shapeScaleStyling.isLogarithmic = true;\n\n        // setting up ShapeComparisonStyling:\n        this.shapeRangeStyling = new ShapeRangeStyling();\n        this.shapeRangeStyling.defaultFill = 'Gray';\n        this.shapeRangeStyling.itemMemberPath = 'Population';\n        this.shapeRangeStyling.ranges = [\n            { fill: 'yellow', minimum: 5000, maximum: 10000000, },        // 5 K - 10 M\n            { fill: 'orange', minimum: 10000000, maximum: 100000000, },   // 10 M - 100 M\n            { fill: 'red',    minimum: 100000000, maximum: 500000000, },  // 100 M - 500 M\n            { fill: 'brown',  minimum: 500000000, maximum: 2000000000, }, // 500 M - 2 B\n        ];\n\n        // setting up ShapeComparisonStyling:\n        this.shapeComparisonStyling = new ShapeComparisonStyling();\n        this.shapeComparisonStyling.defaultFill = 'Gray';\n        this.shapeComparisonStyling.itemMemberPath = 'Region';\n        this.shapeComparisonStyling.itemMappings = [\n            { fill: 'Red', itemValue: 'Central Asia' },\n            { fill: 'Red', itemValue: 'Eastern Asia' },\n            { fill: 'Orange', itemValue: 'Southern Asia' },\n            { fill: 'Orange', itemValue: 'Middle East' },\n            { fill: 'Orange', itemValue: 'Northern Africa' },\n            { fill: 'Yellow', itemValue: 'Eastern Africa' },\n            { fill: 'Yellow', itemValue: 'Western Africa' },\n            { fill: 'Yellow', itemValue: 'Middle Africa' },\n            { fill: 'Yellow', itemValue: 'Southern Africa' },\n            { fill: 'DodgerBlue', itemValue: 'Central America' },\n            { fill: 'DodgerBlue', itemValue: 'Northern America' },\n            { fill: 'DodgerBlue', itemValue: 'Western Europe' },\n            { fill: 'DodgerBlue', itemValue: 'Southern Europe' },\n            { fill: 'DodgerBlue', itemValue: 'Northern Europe' },\n            { fill: 'DodgerBlue', itemValue: 'Eastern Europe' },\n            { fill: '#22c928', itemValue: 'South America' },\n            { fill: '#b64fff', itemValue: 'Melanesia' },\n            { fill: '#b64fff', itemValue: 'Micronesia' },\n            { fill: '#b64fff', itemValue: 'Polynesia' },\n            { fill: '#b64fff', itemValue: 'Australia' },\n            // { fill: 'Gray', itemValue: 'Antarctica' },\n        ];\n\n        // setting default value for current shape styling\n        this.currentShapeStyling = this.shapeComparisonStyling;\n    }\n\n    public render(): JSX.Element {\n        return (\n            <div className=\"container sample\">\n                <div className=\"options horizontal\">\n                    <label >Shape Styling:</label>\n                    <select value={this.state.stylingType}\n                            onChange={this.onOptionsSelected}\n                            style={{width: \"14rem\"}}>\n                            <option>ShapeComparisonStyling</option>\n                            <option>ShapeScaleStyling</option>\n                            <option>ShapeRangeStyling</option>\n                            <option>ShapeRandomStyling</option>\n                    </select>\n                </div>\n                <div className=\"container\" >\n                    <IgrGeographicMap\n                        ref={this.onMapRef}\n                        width=\"100%\"\n                        height=\"100%\"\n                        zoomable=\"true\"/>\n                </div>\n            </div>\n        );\n    }\n\n    public onMapRef(geoMap: IgrGeographicMap) {\n        if (!geoMap) { return; }\n\n        this.geoMap = geoMap;\n        this.geoMap.backgroundContent = undefined;\n\n        // loading a shapefile with geographic polygons\n        const sds = new IgrShapeDataSource();\n        sds.importCompleted = this.onDataLoaded;\n        sds.shapefileSource = \"https://static.infragistics.com/xplatform/shapes/world_countries_all.shp\";\n        sds.databaseSource  = \"https://static.infragistics.com/xplatform/shapes/world_countries_all.dbf\";\n        sds.dataBind();\n    }\n\n    public onDataLoaded(sds: IgrShapeDataSource, e: any) {\n        this.shapeRecords = sds.getPointData();\n        console.log(\"loaded WorldCountries.shp \" +  this.shapeRecords.length);\n\n        this.geoSeries = new IgrGeographicShapeSeries ( { name: \"series\" });\n        this.geoSeries.dataSource = this.shapeRecords;\n        this.geoSeries.shapeMemberPath = \"points\";\n        this.geoSeries.brush = \"rgba(146, 146, 146, 0.6)\";\n        this.geoSeries.outline = \"Black\";\n        this.geoSeries.tooltipTemplate = this.createTooltip;\n        this.geoSeries.thickness = 1;\n        // adding event handler for styleShape\n        this.geoSeries.styleShape = this.onStylingShape;\n\n        this.geoMap.series.add(this.geoSeries);\n    }\n\n    public onStylingShape(s: IgrGeographicShapeSeries, args: IgrStyleShapeEventArgs) {\n\n        const itemRecord = args.item as IgrShapefileRecord;\n\n        const shapeStyle = this.currentShapeStyling.generate(itemRecord);\n        args.shapeOpacity = shapeStyle.opacity;\n        args.shapeFill = shapeStyle.fill;\n        args.shapeStroke = shapeStyle.stroke;\n        args.shapeStrokeThickness = shapeStyle.strokeThickness;\n    }\n\n    public onOptionsSelected = (e: any) => {\n        const stylingType = e.target.value;\n\n        if (stylingType === 'ShapeComparisonStyling') {\n            this.currentShapeStyling = this.shapeComparisonStyling;\n        } else if (stylingType === 'ShapeScaleStyling') {\n            this.currentShapeStyling = this.shapeScaleStyling;\n        } else if (stylingType === 'ShapeRangeStyling') {\n            this.currentShapeStyling = this.shapeRangeStyling;\n        } else {\n            this.currentShapeStyling = this.shapeRandomStyling;\n        }\n\n        this.geoSeries.dataSource = this.shapeRecords;\n        this.setState({ stylingType: stylingType});\n    }\n\n    public createTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        const reg = dataItem.fieldValues.Region;\n        const name = dataItem.fieldValues.Name;\n        const pop = WorldUtils.toStringAbbr(dataItem.fieldValues.Population);\n\n        return <div className=\"tooltipBox\" >\n            <div className=\"tooltipTitle\" > {name}</div>\n            <div className=\"tooltipBox\">\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Region:</div>\n                    <div className=\"tooltipVal\">{reg}</div>\n                </div>\n                <div className=\"tooltipRow\">\n                    <div className=\"tooltipLbl\">Population:</div>\n                    <div className=\"tooltipVal\">{pop}</div>\n                </div>\n            </div>\n        </div>\n    }\n\n}\n\n// rendering above class to the React DOM\nReactDOM.render(<MapShapeStyling />, document.getElementById('root'));\n",
  "isMain": true,
  "fileExtension": "tsx",
  "fileHeader": "tsx"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/shape-styling/src/index.css",
  "content": "",
  "isMain": true,
  "fileExtension": "css",
  "fileHeader": "css"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/shape-styling/src/MapShapeStyleUtility.ts",
  "content": "/* tslint:disable:prefer-const */\r\n\r\nimport { Style } from 'igniteui-react-core';\r\n\r\nexport abstract class ShapeStyling {\r\n  public defaultStroke = 'black';\r\n  public defaultFill = 'gray';\r\n  public defaultThickness = 0.5;\r\n  public defaultOpacity = 1.0;\r\n  public defaultStyle = new Style();\r\n\r\n  constructor() {\r\n    this.defaultStyle = new Style();\r\n    this.defaultStyle.stroke = this.defaultStroke;\r\n    this.defaultStyle.fill = this.defaultFill;\r\n    this.defaultStyle.opacity = this.defaultOpacity;\r\n    this.defaultStyle.strokeThickness = this.defaultThickness;\r\n  }\r\n\r\n  public abstract generate(record: any): Style;\r\n\r\n  public getValue(itemMemberPath: string, item: any): any {\r\n    let itemValue = null;\r\n\r\n    if (item.fieldValues !== undefined) { // .hasOwnProperty(\"fieldValues\")) {\r\n      if (item.fieldsNames.indexOf(itemMemberPath) >= 0) {\r\n        itemValue = item.fieldValues[itemMemberPath];\r\n      } else {\r\n        console.log('WARNING: ShapefileRecord does not have ' + itemMemberPath + ' in fieldValues property');\r\n      }\r\n    } else if (item.hasOwnProperty(itemMemberPath)) {\r\n      itemValue = item[itemMemberPath];\r\n    } else {\r\n      console.log('WARNING: Shape data item does not have ' + itemMemberPath + ' property');\r\n    }\r\n    return itemValue;\r\n  }\r\n}\r\n\r\nexport class ShapeRandomStyling extends ShapeStyling {\r\n\r\n  public shapeThickness = 0.5;\r\n  public shapeOpacity = 1.0;\r\n  public shapeStrokeColors = ['black'];\r\n  public shapeFillColors   = ['red', 'orange', 'yellow'];\r\n\r\n  public styleMappings = new Map<string, Style>();\r\n\r\n  public generate(record: any): Style {\r\n    const id = record.fieldValues.Name || this.getRandomValue(0, 1000);\r\n\r\n    if (this.styleMappings.has(id)) {\r\n      return this.styleMappings.get(id);\r\n    } else {\r\n      const randStroke = this.getRandomItem(this.shapeStrokeColors);\r\n      const randFill = this.getRandomItem(this.shapeFillColors);\r\n      const shapeStyle = new Style();\r\n      shapeStyle.stroke = this.shapeStrokeColors[randStroke];\r\n      shapeStyle.fill = this.shapeFillColors[randFill];\r\n      shapeStyle.opacity = this.shapeOpacity;\r\n      shapeStyle.strokeThickness = this.shapeThickness;\r\n      this.styleMappings.set(id, shapeStyle);\r\n      return shapeStyle;\r\n    }\r\n  }\r\n\r\n  public getRandomValue(min: number, max: number): number {\r\n      return Math.round(min + (Math.random() * (max - min)));\r\n  }\r\n  public getRandomItem(array: any[]): any {\r\n    return this.getRandomValue(0, array.length - 1);\r\n  }\r\n}\r\n\r\nexport class ShapeScaleStyling extends ShapeStyling {\r\n\r\n  public shapeThickness = 0.5;\r\n  public shapeOpacity = 1.0;\r\n  public shapeStrokeColors = ['black'];\r\n  public shapeFillColors   = ['red', 'orange', 'yellow'];\r\n\r\n  public itemMemberPath = '';\r\n  public itemMinimumValue = 0;\r\n  public itemMaximumValue = 1000;\r\n\r\n  public isLogarithmic = true;\r\n\r\n  public generate(record: any): Style {\r\n\r\n    let itemValue = this.getValue(this.itemMemberPath, record);\r\n    if (itemValue === null) {\r\n      return this.defaultStyle;\r\n    }\r\n\r\n    let fillColor = this.defaultFill;\r\n    let strokeColor = this.defaultStroke;\r\n    let scaleValue = this.getScaledValue(itemValue);\r\n\r\n    if (!Number.isNaN(scaleValue)) {\r\n      let fillIndex = Math.round(scaleValue * (this.shapeFillColors.length - 1));\r\n      let strokeIndex = Math.round(scaleValue * (this.shapeStrokeColors.length - 1));\r\n      fillColor = this.shapeFillColors[fillIndex];\r\n      strokeColor = this.shapeStrokeColors[strokeIndex];\r\n    }\r\n\r\n    const shapeStyle = new Style();\r\n    shapeStyle.fill = fillColor;\r\n    shapeStyle.stroke  = strokeColor;\r\n    shapeStyle.strokeThickness = this.shapeThickness;\r\n    shapeStyle.opacity = this.shapeOpacity;\r\n    return shapeStyle;\r\n  }\r\n\r\n  public getScaledValue(value: number): number {\r\n\r\n      if (!Number.isFinite(value) || Number.isNaN(value)) { return Number.NaN; }\r\n\r\n      let min = !Number.isFinite(this.itemMinimumValue) || Number.isNaN(this.itemMinimumValue) ? 0 : this.itemMinimumValue;\r\n      let max = !Number.isFinite(this.itemMaximumValue) || Number.isNaN(this.itemMaximumValue) ? 1000 : this.itemMaximumValue;\r\n\r\n      if (value < min || value > max) { return Number.NaN; }\r\n\r\n      if (this.isLogarithmic) {\r\n        return this.getLogarithmicValue(min, max, value);\r\n      } else {\r\n        return this.getLinearValue(min, max, value);\r\n      }\r\n  }\r\n\r\n  public getLogarithmicValue(min: number, max: number, value: number) {\r\n      if (!Number.isFinite(value)) { return Number.NaN; }\r\n\r\n      let newMin = Math.log10(min);\r\n      let newMax = Math.log10(max);\r\n      let newVal = Math.log10(value);\r\n\r\n      if (!Number.isFinite(newMin)) { newMin = 0.0; }\r\n      if (!Number.isFinite(newMax)) { newMax = 1000; }\r\n\r\n      if (newVal < 0) { newVal = 0.0; }\r\n\r\n      return this.getLinearValue(newMin, newMax, newVal);\r\n  }\r\n\r\n  public getLinearValue(min: number, max: number, value: number) {\r\n\r\n      if (!Number.isFinite(value)) { return Number.NaN; }\r\n\r\n      // if the value is outside the range\r\n      if (value < min || value > max) { return Number.NaN; }\r\n\r\n      let scaledValue = (value - min) / (max - min);\r\n      return scaledValue;\r\n  }\r\n\r\n}\r\n\r\nexport class ShapeRangeStyling extends ShapeStyling {\r\n\r\n  public itemMemberPath = '';\r\n  public ranges: ShapeRange[] = [];\r\n\r\n  constructor() {\r\n    super();\r\n    this.ranges.push({ minimum: 0, maximum: 50, fill: 'yellow'} );\r\n    this.ranges.push({ minimum: 0, maximum: 100, fill: 'red'} );\r\n  }\r\n\r\n  public generate(record: any): Style {\r\n    let itemValue = this.getValue(this.itemMemberPath, record);\r\n    if (itemValue === null) {\r\n      return this.defaultStyle;\r\n    }\r\n\r\n    for (const range of this.ranges) {\r\n      if (range.minimum <= itemValue && itemValue < range.maximum) {\r\n        const shapeStyle = new Style();\r\n        shapeStyle.opacity = range.opacity || this.defaultOpacity;\r\n        shapeStyle.fill    = range.fill || this.defaultFill;\r\n        shapeStyle.stroke  = range.stroke || this.defaultStroke;\r\n        shapeStyle.strokeThickness = range.strokeThickness || this.defaultThickness;\r\n        return shapeStyle;\r\n      }\r\n    }\r\n    return this.defaultStyle;\r\n  }\r\n}\r\n\r\nexport class ShapeRange {\r\n\r\n  public minimum: number;\r\n  public maximum: number;\r\n\r\n  public opacity?: number;\r\n  public fill: string;\r\n  public stroke?: string;\r\n  public strokeThickness?: number;\r\n\r\n}\r\n\r\nexport class ShapeComparisonStyling extends ShapeStyling {\r\n\r\n  public itemMemberPath = '';\r\n  public itemMappings: ShapeComparison[] = [];\r\n\r\n  public generate(record: any): Style {\r\n\r\n    let itemValue = this.getValue(this.itemMemberPath, record);\r\n    if (itemValue === null || itemValue === \"\") {\r\n      return this.defaultStyle;\r\n    }\r\n\r\n    for (const mapping of this.itemMappings) {\r\n      if (mapping.itemValue === itemValue) {\r\n        const shapeStyle = new Style();\r\n        shapeStyle.opacity = mapping.opacity || this.defaultOpacity;\r\n        shapeStyle.fill    = mapping.fill || this.defaultFill;\r\n        shapeStyle.stroke  = mapping.stroke || this.defaultStroke;\r\n        shapeStyle.strokeThickness = mapping.strokeThickness || this.defaultThickness;\r\n        return shapeStyle;\r\n      }\r\n    }\r\n\r\n    return this.defaultStyle;\r\n  }\r\n}\r\n\r\nexport class ShapeComparison {\r\n  public itemValue: string;\r\n\r\n  public opacity?: number;\r\n  public fill: string;\r\n  public stroke?: string;\r\n  public strokeThickness?: number;\r\n}\r\n",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/shape-styling/src/WorldUtils.ts",
  "content": "export default class WorldUtils {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        let interval = 200;\r\n        let paths: any[] = [[]];\r\n        let pathID = 0;\r\n        let distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval)\r\n            {\r\n                previous = current\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                let bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: -180, lat: current.lat }\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: 180, lat: current.lat }\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number\r\n    {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let range = (dest.lon - origin.lon);\r\n        let y = Math.sin(range) * Math.cos(dest.lat);\r\n        let x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        let angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        let radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180º and +180º\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon: lon, lat: lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        let lonDelta = (dest.lon - origin.lon);\r\n\r\n        let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        let distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        let x = this.toRadians(geoPoint.lon);\r\n        let y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number\r\n    {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number\r\n    {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        let str = Math.abs(latitude).toFixed(1) + \"°\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        let val = Math.abs(coordinate);\r\n        let str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\"\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\"\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\"\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\"\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) return location.x;\r\n        if (location.lon) return location.lon;\r\n        if (location.longitude) return location.longitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) return location.y;\r\n        if (location.lat) return location.lat;\r\n        if (location.latitude) return location.latitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n\r\n            // if (location.x) {\r\n            //     minLon = Math.min(minLon, location.x);\r\n            //     maxLon = Math.max(maxLon, location.x);\r\n            // } else if (location.lon) {\r\n            //     minLon = Math.min(minLon, location.lon);\r\n            //     maxLon = Math.max(maxLon, location.lon);\r\n            // } else if (location.longitude) {\r\n            //     minLon = Math.min(minLon, location.longitude);\r\n            //     maxLon = Math.max(maxLon, location.longitude);\r\n            // }\r\n            // if (location.y) {\r\n            //     minLat = Math.min(minLat, location.y);\r\n            //     maxLat = Math.max(maxLat, location.y);\r\n            // } else if (location.lat) {\r\n            //     minLat = Math.min(minLat, location.lat);\r\n            //     maxLat = Math.max(maxLat, location.lat);\r\n            // } else if (location.latitude) {\r\n            //     minLat = Math.min(minLat, location.latitude);\r\n            //     maxLat = Math.max(maxLat, location.latitude);\r\n            // }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n\r\n    public static getNightShapes(): any[] {\r\n        let nightShape = [];\r\n\r\n        let line: any[] = [];\r\n\r\n        for (let lon = -180; lon <= 180; lon += 1) {\r\n\r\n            // let line: any[] = [{x: lon, y: -90}, {x: lon, y: 90}];\r\n            let x = lon;\r\n            let y = 75 * Math.cos(lon * Math.PI / 180);\r\n            line.push({x: x, y: y});\r\n        }\r\n        // line.push({x: 180, y: 90});\r\n        // line.push({x: -180, y: 90});\r\n        // line.push({x: -180, y: -90});\r\n\r\n        let coordinateLine = {points: [line]};\r\n\r\n        nightShape.push(coordinateLine);\r\n\r\n        return nightShape;\r\n    }\r\n\r\n}",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 }
]
}