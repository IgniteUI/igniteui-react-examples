{
 "sampleFiles":
[
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/type-scatter-area-series/src/index.tsx",
  "content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport WorldUtils from \"./WorldUtils\"\nimport { LegendOverlay, LegendItem } from \"./LegendOverlay\"\nimport { IgrGeographicMapModule } from 'igniteui-react-maps';\nimport { IgrGeographicMap } from 'igniteui-react-maps';\nimport { IgrGeographicScatterAreaSeries } from 'igniteui-react-maps';\nimport { IgrGeographicSymbolSeries } from 'igniteui-react-maps';\nimport { IgrValueBrushScale } from 'igniteui-react-charts';\nimport { IgrCustomPaletteColorScale } from 'igniteui-react-charts';\nimport { IgrDataChartInteractivityModule } from 'igniteui-react-charts';\nimport { MarkerType } from 'igniteui-react-charts';\nimport { IgrShapeDataSource } from 'igniteui-react-core';\nimport { IgrDataContext } from 'igniteui-react-core';\n\nIgrGeographicMapModule.register();\nIgrDataChartInteractivityModule.register();\n\nexport default class MapTypeScatterAreaSeries extends React.Component<any, any> {\n\n    private geoMap: IgrGeographicMap;\n\n    constructor(props: any) {\n        super(props);\n\n        this.onMapRef = this.onMapRef.bind(this);\n        this.onDataLoaded = this.onDataLoaded.bind(this);\n    }\n\n    public render(): JSX.Element {\n        return (\n            <div className=\"container sample\" >\n                <IgrGeographicMap\n                    ref={this.onMapRef}\n                    width=\"100%\"\n                    height=\"100%\"\n                    zoomable=\"true\" />\n                <LegendOverlay dock=\"BottomLeft\"\n                text=\"Source: NOAA\" href=\"https://www.noaa.gov/\" />\n                <div className=\"overlay-bottom-right overlay-border\">Imagery Tiles: @OpenStreetMap</div>\n            </div>\n        );\n    }\n\n    public onMapRef(geoMap: IgrGeographicMap) {\n        if (!geoMap) { return; }\n\n        this.geoMap = geoMap;\n        this.geoMap.windowRect = { left: 0.2, top: 0.1, width: 0.6, height: 0.6 };\n\n        // loading a shapefile with geographic shapes\n        const sds = new IgrShapeDataSource();\n        sds.importCompleted = this.onDataLoaded;\n        sds.shapefileSource = \"https://static.infragistics.com/xplatform/shapes/WorldTemperatures.shp\";\n        sds.databaseSource  = \"https://static.infragistics.com/xplatform/shapes/WorldTemperatures.dbf\";\n        sds.dataBind();\n    }\n\n    public onDataLoaded(sds: IgrShapeDataSource, e: any) {\n        const shapeRecords = sds.getPointData();\n        console.log(\"loaded WorldTemperatures.shp: \" + shapeRecords.length);\n\n        const contourPoints: any[] = [];\n        for (const record of shapeRecords) {\n            const temp = record.fieldValues.Contour;\n            // using only major contours (every 10th degrees Celsius)\n            if (temp % 10 === 0 && temp >= 0) {\n                for (const shapes of record.points) {\n                     for (let i = 0; i < shapes.length; i++) {\n                        if (i % 5 === 0) {\n                            const point = shapes[i];\n                            const item = { lon: point.x, lat: point.y, value: temp};\n                            contourPoints.push(item);\n                        }\n                     }\n                }\n            }\n        }\n\n        console.log(\"loaded contour points: \" + contourPoints.length);\n        this.createAreaSeries(contourPoints);\n    }\n\n    public createAreaSeries(data: any[])\n    {\n        const brushes = [\n            \"rgba(32, 146, 252, 0.5)\", // semi-transparent blue\n            \"rgba(14, 194, 14, 0.5)\",  // semi-transparent green\n            \"rgba(252, 120, 32, 0.5)\", // semi-transparent orange\n            \"rgba(252, 32, 32, 0.5)\",  // semi-transparent red\n        ];\n\n        const colorScale = new IgrCustomPaletteColorScale({});\n        colorScale.palette = brushes;\n        colorScale.minimumValue = 0;\n        colorScale.maximumValue = 30;\n\n        const areaSeries = new IgrGeographicScatterAreaSeries( { name: \"areaSeries\" });\n        areaSeries.dataSource = data;\n        areaSeries.longitudeMemberPath = \"lon\";\n        areaSeries.latitudeMemberPath = \"lat\";\n        areaSeries.colorMemberPath = \"value\";\n        areaSeries.colorScale = colorScale;\n        areaSeries.tooltipTemplate = this.createAreaTooltip;\n\n        this.geoMap.series.add(areaSeries);\n    }\n\n    public createAreaTooltip(context: any) {\n        const dataContext = context.dataContext as IgrDataContext;\n        if (!dataContext) return null;\n\n        const dataItem = dataContext.item as any;\n        if (!dataItem) return null;\n\n        const lat = WorldUtils.toStringLat(dataItem.lat);\n        const lon = WorldUtils.toStringLon(dataItem.lon);\n        const tmp = dataItem.value.toFixed(1) + \"°C\";\n        return <div className=\"tooltipBox\">\n            <div className=\"tooltipRow\">\n                <div className=\"tooltipLbl\">Temperature:</div>\n                <div className=\"tooltipVal\"> {tmp}</div>\n            </div>\n            <div className=\"tooltipRow\">\n                <div className=\"tooltipLbl\">Latitude:</div>\n                <div className=\"tooltipVal\"> {lat}</div>\n            </div>\n            <div className=\"tooltipRow\">\n                <div className=\"tooltipLbl\">Longitude:</div>\n                <div className=\"tooltipVal\"> {lon}</div>\n            </div>\n        </div>\n    }\n}\n\n// rendering above class to the React DOM\nReactDOM.render(<MapTypeScatterAreaSeries />, document.getElementById('root'));\n",
  "isMain": true,
  "fileExtension": "tsx",
  "fileHeader": "tsx"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/type-scatter-area-series/src/index.css",
  "content": "",
  "isMain": true,
  "fileExtension": "css",
  "fileHeader": "css"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/type-scatter-area-series/src/LegendOverlay.css",
  "content": ".LegendOverlay {\r\n    border-radius: 3px;\r\n    background: rgba(221, 221, 221, 0.671);\r\n    position: absolute;\r\n    padding-left: 4px;\r\n    padding-right: 4px;\r\n    padding-top: 4px;\r\n    padding-bottom: 4px;\r\n    margin-left: 2px;\r\n    margin-top: 2px;\r\n    margin-right: 2px;\r\n    margin-bottom: 2px;\r\n    pointer-events: none;\r\n    font-family: Lato, Helvetica, sans-serif;\r\n    font-size: 10px;\r\n    color: #2c2c2c;\r\n}\r\n\r\n.LegendItem {\r\n    /* height: 12px; */\r\n    /* width: 10px; */\r\n    /* background: rgb(5, 91, 219); */\r\n    display: block;\r\n    margin-left: 2px;\r\n    margin-right: 2px;\r\n    margin-top: 0px;\r\n    /* border-radius: 3px; */\r\n    text-decoration: none;\r\n}\r\n\r\n.LegendItemMap {\r\n    height: 12px;\r\n    width: 12px;\r\n    background: rgb(35, 36, 36);\r\n    background: rgb(5, 91, 219);\r\n    display: inline-block;\r\n    /* margin-left: 2px; */\r\n    /* margin-top: 2px; */\r\n    margin-top: 1px;\r\n    border-radius: 3px;\r\n}\r\n\r\n.LegendItemLabel {\r\n    /* background: rgb(97, 241, 186); */\r\n    /* width: 115px; */\r\n    display: inline-block;\r\n    /* vertical-align: text-top; */\r\n    margin-left: 5px;\r\n    margin-right: 5px;\r\n    font-size: 10px;\r\n}\r\n\r\n.SourceLabel {\r\n    display: block;\r\n    margin-left: 4px;\r\n    margin-right: 4px;\r\n    margin-top: 4px;\r\n    margin-bottom: 4px;\r\n    font-size: 10px;\r\n    font-family: Lato, Helvetica, sans-serif;\r\n    color: #2c2c2c;\r\n    background: #f0f1f100;\r\n}\r\n\r\n.SourceStyle {\r\n    display: block;\r\n    margin-left: 2px;\r\n    margin-right: 2px;\r\n    margin-top: 2px;\r\n    margin-bottom: 2px;\r\n    font-size: 10px;\r\n    font-family: Lato, Helvetica, sans-serif;\r\n    color: #2c2c2c;\r\n    background: #f0f1f100;\r\n    pointer-events: auto;\r\n}\r\n\r\n.SourceStyle a {\r\n    color: #1362f5 !important;\r\n    background: #f0f1f100 !important;\r\n    pointer-events: auto;\r\n}\r\n\r\n.SourceStyle a:hover {\r\n    /* color: #134ff5; */\r\n    color: #2c2c2c !important;\r\n    background: #f0f1f100 !important;\r\n    pointer-events: auto;\r\n}\r\n",
  "isMain": true,
  "fileExtension": "css",
  "fileHeader": "css"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/type-scatter-area-series/src/LegendOverlay.tsx",
  "content": "import React from \"react\";\r\nimport \"./LegendOverlay.css\";\r\n\r\nexport class LegendOverlay extends React.Component<any, any> {\r\n\r\n    public render(): JSX.Element {\r\n\r\n        let bg: string = this.props.background;\r\n        if (bg === undefined) { bg = \"rgba(221, 221, 221, 0.65)\"; }\r\n\r\n        let style = { background: bg, bottom: 3, left: 3 } as React.CSSProperties;\r\n\r\n        const dock: string = this.props.dock;\r\n        if (dock === \"TopRight\") {\r\n            style = { background: bg, top: 3, right: 3 } as React.CSSProperties;\r\n        }\r\n        else if (dock === \"TopLeft\") {\r\n            style = { background: bg, top: 3, left: 3 } as React.CSSProperties;\r\n        }\r\n        else if (dock === \"BottomRight\") {\r\n            style = { background: bg, bottom: 3, right: 3 } as React.CSSProperties;\r\n        }\r\n        else  { // if (dock === \"BottomLeft\")\r\n            style = { background: bg, bottom: 3, left: 3 } as React.CSSProperties;\r\n        }\r\n\r\n        // let title: JSX.Element;\r\n\r\n        const hasLink = this.props.href !== undefined || this.props.text !== undefined;\r\n        return hasLink ?\r\n            <div className=\"LegendOverlay\" style={style}>\r\n                <LegendLink text={this.props.text} href={this.props.href}  />\r\n                <div   >\r\n                    {this.props.children}\r\n                </div>\r\n            </div>\r\n            :\r\n            <div className=\"LegendOverlay\" style={style}>\r\n                <div   >\r\n                    {this.props.children}\r\n                </div>\r\n            </div>\r\n\r\n        // return (\r\n            // <div className=\"LegendOverlay\" style={style}>\r\n            //     {this.props.children}\r\n            // </div>\r\n        // );\r\n    }\r\n}\r\n\r\nexport class LegendItem extends React.Component<any, any> {\r\n\r\n    public render(): JSX.Element {\r\n        const bg = this.props.background;\r\n        const bgStyle = { background: bg } as React.CSSProperties;\r\n\r\n        return (\r\n            <div  className=\"LegendItem\">\r\n                <div   className=\"LegendItemMap\" style={bgStyle}/>\r\n                <label className=\"LegendItemLabel\">{this.props.text}</label>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class LegendLink extends React.Component<any, any> {\r\n\r\n    public render(): JSX.Element {\r\n        const hasLink = this.props.href !== undefined;\r\n\r\n        return hasLink ?\r\n        <div className=\"SourceStyle\">\r\n            <a target=\"_blank\" href={this.props.href} rel=\"noopener noreferrer\">\r\n            {this.props.text}</a>\r\n        </div> :\r\n        // <div >\r\n            <label className=\"SourceLabel\">{this.props.text}</label>\r\n        // </div>\r\n    }\r\n}\r\n",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 },
 {
  "hasRelativeAssetsUrls": false,
  "path": "../samples/maps/geo-map/type-scatter-area-series/src/WorldUtils.ts",
  "content": "export default class WorldUtils {\r\n\r\n    // calculate geo-paths between two locations using great circle formula\r\n    public static calcPaths(origin: any, dest: any): any[] {\r\n        let interval = 200;\r\n        let paths: any[] = [[]];\r\n        let pathID = 0;\r\n        let distance = this.calcDistance(origin, dest);\r\n        if (distance <= interval) {\r\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        } else {\r\n            let current = origin;\r\n            let previous = origin;\r\n\r\n            for (let dist = interval; dist <= distance; dist += interval)\r\n            {\r\n                previous = current\r\n                paths[pathID].push({ x: current.lon, y: current.lat });\r\n\r\n                let bearing = this.calcBearing(current, dest);\r\n                current = this.calcDestination(current, bearing, interval);\r\n                // ensure geo-path wrap around the world through the new date-line\r\n                if (previous.lon > 150 && current.lon < -150) {\r\n                    paths[pathID].push({ x: 180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: -180, lat: current.lat }\r\n                } else if (previous.lon < -150 && current.lon > 150) {\r\n                    paths[pathID].push({ x: -180, y: current.lat });\r\n                    paths.push([]);\r\n                    pathID++\r\n                    current = { lon: 180, lat: current.lat }\r\n                }\r\n            }\r\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\r\n        }\r\n        return paths;\r\n    }\r\n\r\n    // calculate bearing angle between two locations\r\n    public static calcBearing(origin: any, dest: any): number\r\n    {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let range = (dest.lon - origin.lon);\r\n        let y = Math.sin(range) * Math.cos(dest.lat);\r\n        let x = Math.cos(origin.lat) * Math.sin(dest.lat) -\r\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\r\n        let angle = Math.atan2(y, x);\r\n        return this.toDegreesNormalized(angle);\r\n    }\r\n\r\n    // calculate destination for origin location and travel distance\r\n    public static calcDestination(origin: any, bearing: number, distance: number): any {\r\n        let radius = 6371.0;\r\n        origin = this.toRadianLocation(origin);\r\n        bearing = this.toRadians(bearing);\r\n        distance = distance / radius; // angular distance in radians\r\n\r\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\r\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\r\n        let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\r\n        let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\r\n        let lon = origin.lon + Math.atan2(x, y);\r\n        // normalize lon to coordinate between -180º and +180º\r\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\r\n\r\n        lon = this.toDegrees(lon);\r\n        lat = this.toDegrees(lat);\r\n\r\n        return { lon: lon, lat: lat };\r\n    }\r\n\r\n    // calculate distance between two locations\r\n    public static calcDistance(origin: any, dest: any): number {\r\n        origin = this.toRadianLocation(origin);\r\n        dest = this.toRadianLocation(dest);\r\n        let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\r\n        let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\r\n        let lonDelta = (dest.lon - origin.lon);\r\n\r\n        let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\r\n        let distance = angle * 6371.0;\r\n        return distance; // * 6371.0; // in km\r\n    }\r\n\r\n    public static toRadianLocation(geoPoint: any): any {\r\n        let x = this.toRadians(geoPoint.lon);\r\n        let y = this.toRadians(geoPoint.lat);\r\n        return { lon: x, lat: y };\r\n    }\r\n\r\n    public static toRadians(degrees: number): number\r\n    {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n\r\n    public static toDegrees(radians: number): number {\r\n        return (radians * 180.0 / Math.PI);\r\n    }\r\n\r\n    public static toDegreesNormalized(radians: number): number\r\n    {\r\n        let degrees = this.toDegrees(radians);\r\n        degrees = (degrees + 360) % 360;\r\n        return degrees;\r\n    }\r\n\r\n    // converts latitude coordinate to a string\r\n    public static toStringLat(latitude: number): string {\r\n        let str = Math.abs(latitude).toFixed(1) + \"°\";\r\n        return latitude > 0 ? str + \"N\" : str + \"S\";\r\n    }\r\n\r\n    // converts longitude coordinate to a string\r\n    public static toStringLon(coordinate: number): string {\r\n        let val = Math.abs(coordinate);\r\n        let str = val < 100 ? val.toFixed(1) : val.toFixed(0);\r\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\r\n    }\r\n\r\n    public static toStringAbbr(value: number): string {\r\n        if (value > 1000000000000) {\r\n            return (value / 1000000000000).toFixed(1) + \" T\"\r\n        } else if (value > 1000000000) {\r\n            return (value / 1000000000).toFixed(1) + \" B\"\r\n        } else if (value > 1000000) {\r\n            return (value / 1000000).toFixed(1) + \" M\"\r\n        } else if (value > 1000) {\r\n            return (value / 1000).toFixed(1) + \" K\"\r\n        }\r\n        return value.toFixed(0);\r\n    }\r\n\r\n    public static getLongitude(location: any): number {\r\n        if (location.x) return location.x;\r\n        if (location.lon) return location.lon;\r\n        if (location.longitude) return location.longitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getLatitude(location: any): number {\r\n        if (location.y) return location.y;\r\n        if (location.lat) return location.lat;\r\n        if (location.latitude) return location.latitude;\r\n        return Number.NaN;\r\n    }\r\n\r\n    public static getBounds(locations: any[]): any {\r\n        let minLat = 90;\r\n        let maxLat = -90;\r\n        let minLon = 180;\r\n        let maxLon = -180;\r\n\r\n        for (const location of locations) {\r\n            const crrLon = this.getLongitude(location);\r\n            if (!Number.isNaN(crrLon)) {\r\n                minLon = Math.min(minLon, crrLon);\r\n                maxLon = Math.max(maxLon, crrLon);\r\n            }\r\n\r\n            const crrLat = this.getLatitude(location);\r\n            if (!Number.isNaN(crrLat)) {\r\n                minLat = Math.min(minLat, crrLat);\r\n                maxLat = Math.max(maxLat, crrLat);\r\n            }\r\n\r\n            // if (location.x) {\r\n            //     minLon = Math.min(minLon, location.x);\r\n            //     maxLon = Math.max(maxLon, location.x);\r\n            // } else if (location.lon) {\r\n            //     minLon = Math.min(minLon, location.lon);\r\n            //     maxLon = Math.max(maxLon, location.lon);\r\n            // } else if (location.longitude) {\r\n            //     minLon = Math.min(minLon, location.longitude);\r\n            //     maxLon = Math.max(maxLon, location.longitude);\r\n            // }\r\n            // if (location.y) {\r\n            //     minLat = Math.min(minLat, location.y);\r\n            //     maxLat = Math.max(maxLat, location.y);\r\n            // } else if (location.lat) {\r\n            //     minLat = Math.min(minLat, location.lat);\r\n            //     maxLat = Math.max(maxLat, location.lat);\r\n            // } else if (location.latitude) {\r\n            //     minLat = Math.min(minLat, location.latitude);\r\n            //     maxLat = Math.max(maxLat, location.latitude);\r\n            // }\r\n        }\r\n\r\n        const geoBounds = {\r\n            left: minLon,\r\n            top: minLat,\r\n            width: Math.abs(maxLon - minLon),\r\n            height: Math.abs(maxLat - minLat)\r\n        };\r\n        return geoBounds;\r\n    }\r\n\r\n    public static getNightShapes(): any[] {\r\n        let nightShape = [];\r\n\r\n        let line: any[] = [];\r\n\r\n        for (let lon = -180; lon <= 180; lon += 1) {\r\n\r\n            // let line: any[] = [{x: lon, y: -90}, {x: lon, y: 90}];\r\n            let x = lon;\r\n            let y = 75 * Math.cos(lon * Math.PI / 180);\r\n            line.push({x: x, y: y});\r\n        }\r\n        // line.push({x: 180, y: 90});\r\n        // line.push({x: -180, y: 90});\r\n        // line.push({x: -180, y: -90});\r\n\r\n        let coordinateLine = {points: [line]};\r\n\r\n        nightShape.push(coordinateLine);\r\n\r\n        return nightShape;\r\n    }\r\n\r\n}",
  "isMain": false,
  "fileExtension": "ts",
  "fileHeader": "ts"
 }
]
}